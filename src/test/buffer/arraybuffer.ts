/**
 * TypedArray
 * 二进制数据缓存区，视图
 * 每一个位置占用当前位的字节
 * 
 * | TYPE            | RANGE                  |   SIZE              |
 * +-----------------+------------------------+---------------------+
 * | Int8Array       | -2 ** 7 ~ 2 ** 7       |   1BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Uint8Arr        | 0 ~ 2 ** 8             |   1BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Uint8ClampedArr | 0 ~ 255  溢出处理不同!  |   1BYTE             |
 * +-------------------+----------------------+---------------------+
 * | Int16Array      | -2 ** 15 ~ 2 ** 15     |   2BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Uint16Array     | 0 ~ 2 ** 16            |   2BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Int32Array      | -2 ** 31 ~ 2 ** 31     |   4BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Uint32Array     | 0 ~ 2 ** 32            |   4BYTE             |
 * +-----------------+------------------------+---------------------+
 * | BigInt64Array   | -2n ** 63n ~ 2n ** 63n |   8BYTE             |
 * +-----------------+------------------------+---------------------+
 * | BigUint64Array  | 0n ~ 2n ** 64n         |   8BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Float32Array    |                        |   4BYTE             |
 * +-----------------+------------------------+---------------------+
 * | Float64Array    |                        |   8BYTE             |
 * +-----------------+------------------------+---------------------+
 * 
 */

let F2 = new Float64Array(20)
F2.fill(25.64455)
// console.log(F2)

/**
 * ArrayBuffer
 * 分配一段内存缓冲区，但是不能直接读写
 * 只能通过 TypedArray DataView 读写
 * 
 * slice方法的实现没有Buffer的性能高
 * 
 * DataView
 * 读写ArrayBuffer
 * 
 * 
 */

let ab = new ArrayBuffer(24)
let view = new DataView(ab)
view.setBigUint64(0, 18446744073709551615n)
console.log(ab)
debugger


/**
 * SharedArrayBuffer
 * 多线程共享内存区域使用
 * 本身无法读写，需通过数据视图读写
 * 
 * 多线程共享内存，最大的问题就是如何防止两个线程同时修改某个地址
 * 当一个线程修改共享内存以后，必须有一个机制让其他线程同步。
 * 保证所有共享内存的操作都是“原子性”的，可以在所有线程内同步
 * Atomics
 * 对SharedArrayBuffer进行原子操作
 * 
 */

// 主线程
// 新建 1KB 共享内存
// const sharedBuffer = new SharedArrayBuffer(1024);
// 主线程将共享内存的地址发送出去
// w.postMessage(sharedBuffer);
// 子线程
// 通过onMessage拿到共享数据，在共享内存上建立视图，供写入数据
// const sharedArray = new Int32Array(sharedBuffer);
